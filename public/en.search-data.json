{"/animated-pixels/docs/apex/01.getting_started/":{"data":{"":"This section gives a general introduction to APEX in Houdini. It assumes a basic understanding Houdini but no specific knowledge of rigging in Houdini.\nAn overview of rigging in Houdini Preparing geometry for APEX Using the Autorig Component to build a basic rig Skeleton Metadata: Preparing the Guide Skeleton Info\nThis set of tutorials were created for Houdini 21. APEX changed significantly between 20.5 and 21. It is strongly recommended to use Houdini 21 to ensure that everything works as expected.","contents#Contents":"00 Rigs in Houdini: A brief introduction to KineFX and APEX 01 Workflow Overview: Overview of setting up an APEX Rig 02 Demo: A Simple Rig: Simple walkthrough of prepping geometry for a rig."},"title":"Getting Started"},"/animated-pixels/docs/apex/01.getting_started/00.rigging_in_houdini/":{"data":{"":"Rigging in Houdini consists of two overlapping systems:\nKineFX: KineFX uses geometry to define a skeleton and is used as the basis for the SOP based rigging tools, motion retargeting and crowd agent setup. APEX: APEX runs on its own execution engine, and is focuses on providing a procedural system for building rigs, tied to an animator friendly viewport state that efficient evaluates the rig. SideFX often use the two terms interchangeably and while there are some distinctions between the two, it makes sense. KineFX and SOPs prepare the skeleton and geometry, with APEX building the rig logic and animation controls.","apex-rigs#APEX Rigs":"While APEX is most often associated with rigging, it stands for All Purpose EXecution framework, and is also used for Houdini’s texturing and compositing framework Copernicus etc. It is an execution framework that runs outside of Houdini, with the emphasis on speed.\nFor rigging purposes, it provides a fast environment for executing the rig and deforming geometry, tied closely to the animation state. The main advantages of APEX are that it offers:\nViewport Oriented: Focusing on providing a fast, interactive viewport, with a range of useful tools for the animator. Flexible:Designed with traditional and ephemeral rigging in mind. Fast Evaluation: APEX graphs are both deferred and offer partial evaluation, using the GPU for geometry deformation. Procedural Graphs: APEX graphs can generate other APEX graph. This allows for procedural rig setup and also ephemeral rigging through procedurally attaching rigs during animation. Geometry: Apex graphs are represented as geometry with attributes. To a certain extent, this probably feels a slightly abstract, other than the UX and speed benefits, however they will hopefully become clearer as we step through the basics of creating a rig in APEX.","kinefx-rigs#KineFX Rigs":"KineFX rigs consist of points and polygon lines. The point contain the joint transform matrices and attributes (transform, local transform, scale, joint name), while the line defines the hierarchy of the skeleton.\nOne of the advantages of skeletons simply being points with a transform matrix is that Houdini’s usual geometry tools can be use to manipulate them, for example creating a skeleton based off a curve, or procedurally adding joints using a resample, or constraining joints to a surface using a primuv lookup.\nKineFX can be used for a wide range of tasks (and people are always using it in new and interesting ways!). It’s core uses would be for:\nMotion Editing: KineFX allows easy retargeting of motion from one rig onto another, cleaning up motion capture data and editing and manipulating motion. Simulation and Dynamics: Similarly to secondary motion, KineFX can be easily passed to solver, for example creating a skeleton for a tree, simulating it in vellum, and using that to deform the tree mesh. Rigs: KineFX fits within the Houdini toolset that most artist are familiar with. It can be used for rigging plants, generating muscle, building procedural rigs editing motion. Secondary Motion: Adding secondary motion on top of existing animation, for example lag, overshoot or jiggle. Given how flexible KineFX is, why would you use APEX? The main reasons that spring to mind are speed and interactivity."},"title":"Rigging in Houdini"},"/animated-pixels/docs/apex/01.getting_started/01.workflow_overview/":{"data":{"":"The basic rigging workflow for APEX is:\nCreate a skeleton (and optionally a guide skeleton) Capture the geometry Pack skin and skeleton for APEX Build rig in APEX Animate the character in the APEX Scene Animate","packed-folders#Packed Folders":"For the skin, skeleton and other data to be moved to the APEX environment it needs to be packed. Packed folders act as a containers. While anything can be put into a packed folder there are some conventions that get used by the default autorigs:\nBase.skel: The deformation skeleton. Guides.skel: The base skeleton, plus helper controls, joints and metadata for the rig. Base.shp: The skin geometry that gets deformed. And in terms of convention there are some default extensions:\nskel: Skeleton Geometry shp: Geometry (e.g. skin/blend shapes etc) rig: Rig logic (as we shall see apex rigs are stored as geometry). Everything used in the animate state is saved as a packed folder. For example:\nAnimation curves are primitives in an animation folder, Ragdoll geometry is just an additional shape folder with the collision geometry. - Constraints and locators are just rig logic in a packed folder that gets added to the rig graph. Control Library containing a shape library for the rig controls. You can add anything you could need to a packed folder to make it available to the rig; you are not restricted to the a specific set of packed folders.","skeleton#Skeleton":"The skeleton is defined by points with a transform attribute. At base, the points need to have:\ns@name: The name of the joint 3@transform: The transform matrix","skinning#Skinning":"The other main thing you need to have is a skinned mesh. There are three main ways to capture geometry in Houdini:\nJoint Capture Biharmonic: Uses biharmonic weighting to capture the geometry. Usually gives a good base weight with minimal tweaking. Proximity Capture: Captures based off proximity. Useful for things like cluster weights or simple weighting. Packed Capture: Captures packed geometry. This is useful for rigid objects or mechanical rigging. There are also the usual array of controls for painting or manipulating weights, however with a bit of forethought it is usually possible to create procedural skin weighting avoiding having to manually paint weights."},"title":"Workflow Overview"},"/animated-pixels/docs/apex/01.getting_started/02.building_a_simple_rig/":{"data":{"":"The easiest way to see how this works is with a quick example. Rather than building everything from scratch, this will walk through this hip file: getting_startes.simple_rig.hiplc","apex-nodes#APEX Nodes":"Next up we have the APEX nodes. In this part of the network we are going to use the APEX Autorig Component node to build the rig from out skeleton. In our initial setup we are going to create use two autorig components:\nFK Transform: Adds controls for all the joints on the skeleton. Bone Deform: Deforms the skeleton using the joints. Tip\nEach autorig component has its own animate state so you can test the rig interactively as you build it.","apex-scene-animate#APEX Scene Animate":"The final node in our SOP chain is the APEX animate state. This is the node that the animator will use, and is focused on providing a fast interactive environment for animation alongside a suite of useful animation tools (from transient constraints to FBIK and physics).\nOur Capybara’s arm already had a bit of animation on it; if you scrub the timeline the arm and fingers should bend. Not the greatest animation perhaps, but there to prove a point; if you go back to the geometry network and switch the switch_delete_fingers to 1, you should see the fingers disappear, however the animation remains unchanged, similarly, setting it back to zero and the fingers should reappear with their animation.\nThis simple setup is fully procedural; as long as the controller names don’t change you can add additional features to the rig, but preserve the animation without having to throw away keyframes. Additionally you can swap in different packed folders, for example adding a different character, and still preserve the existing animation.\nYour browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player!","create-the-rig-joints#Create The Rig Joints":"If you display the Create Joint Rig node and press enter in the viewport, you will see a control for each of the joints.\nAnd if you open an APEX Network View pane, it should look like this: The Autorig Component displays the nodes created by the current autorig component in green.\nThe FK Transform component is creating a Transform Object for each of the joints in the skeleton. These are the controllers that the animator interacts with. On the far right is the Input node; any Chanels plugged in here are promoted. For the joints we’ve promoted the rotation channel. The Point Transform takes the transform matrices from the Transform Objects and transforms the skeleton geometry by them.","deform-the-geometry#Deform The Geometry":"The second Autorig Component add the nodes necessary to deform the skin geometry.\nThis is the same at the SOP Joint Deform node. It takes the rest skeleton, the animated skeleton and uses the transforms to deform the skin geometry.","next-steps#Next Steps":"This covers the basic workflow of getting the rig into\nGuide Skeleton: The guide skeleton allows us to add additional joints and metadata which can be used by the components and autorig builder. Auotrig Components:","preparing-geometry-for-apex#Preparing Geometry For APEX":"The first step it to prepare the geometry for using it in APEX. This consists of three main steps:\nBuilding the Skeleton (optionally defining a guide skeleton) Capturing the skin Pack geometry into folders for apex. Skin: For this example we are going to be skinning the arm of the capybara. The first thing we want to do is delete everything apart from the arm. Skeleton: For the base skel, we use the skeleton node to create the skeleton. We can use the rig pane to quickly rename the joints as we create them. The Orient Joint node is used to orient the joints down the z axis. Guides: For the guides we are simply adding a tag to specify the arm segment. Tags are just a string array that exists on the Guides skeleton. Here we are just tagging the arm joints, which we are going to use later to apply a basic IK component procedurally. Tip\nThe pack folder SOP automatically names the folders it creates from the input node, and will automatically separate the name and extension for you."},"title":"A Simple Rig"},"/animated-pixels/docs/apex/01.getting_started/03.rig_metadata/":{"data":{"":"Guides allow you to build additional joint on top of the deformation skeleton.","adding-tags#Adding Tags":"Your browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player! To add tags in viewport, display the set tags node.Then in the viewport select the joints you want to add the tags to and press ‘a’. Type in the name of the tag you want to add and press enter. For this example we want to create two tags:\nFirst select the finger joints on both arms and tag them as ‘fk’. Secondly, select the arm, elbow and hand joints on the the left arm and tag them as ‘l_arm’ and tag the same joints on the right arm and tag them ‘r_arm’.","example-1-adding-tags#Example 1: Adding Tags":"As a quick example of how the Guides.skel, tags and joint metadata can be used, we’re going to quickly walk through how to apply tags then add a basic IK chain to the Capybara.","example-2-control-options-and-guides#Example 2: Control Options and Guides":"This second example uses the same file as the previous one.\nAs mentioned above, there’s a variety of metadata that can be attached to each joint (point) on the skeleton. This can control the shape or the colour of the controller, as well as setting limits on the controller and defining the channels which get promoted.\nIn the example file we are:\nCopying the elbow joint and offsetting it, to give us our pole vector controller. Creating a dictionary which defines the look of the controller and promotes just the translate channel. Finally we mirror the pole vector joint and parent it to the hand joint.","example-file#Example File":"Download the example file here: getting_started.tags.hiplc","joint-metadata-setup#Joint Metadata Setup":"The vex code for setting up the properties dictionary in the set_properties attribute wrange is:\n// Set the Control Dictionary dict control = set( 'shapeoverride', 'box_wires', 'color', set(0,1,0) ); // Set properties dictionary d@properties = set( 'control', control, 'max_lock:t', set(0.5,0.5,0.5), 'min_lock:t', set(-0.5,-0.5,-0.5), 'promote', 't' ); Which generates a dictionary which should look like this:\n{ \"control\":{ \"color\":[0,1,1], \"shapeoverride\":\"box_wires\" }, \"max_lock:t\":[0.5,0.5,0.5], \"min_lock:t\":[-0.5,-0.5,-0.5], \"promote\", \"t\" } In the animate state of the Autorig Component there should be two large wireframe boxes, and if you try and move them they will be limited to the range set in the properties dictionary. Additionally, rotating the hand joints will rotate the pole vector controllers; the hierarchy we defined in the Guide skeleton has been brought across to our rig.","propterties#Propterties":"Another attribute that can be defined on the skeleton are properties. These can be used to define a range of properties on the controls generated from the shape, size and colour of the controller, to which handles get promoted for the animator to use. Properties are defined by a dictionary point attribute on the joint.\nFor example, the vex below will set the colour, shape and promoted the t and s handles:\ndict d; d['color'] = set(1.0, 1.0, 0.0); d@properties['control'] = d; d@properties['promote'] = 't s'; d@properties['shape'] = 'box'; Which would give use this dictionary:\n{ \"control\":{ \"color\":[1,1,0] }, \"promote\":\"t s\", \"shape\":\"box\" } Another way to setup controls would be using the APEX Configure Controls SOP, or on the Transform Objects on the rig (which is where these attributes are ultimately used). It can be useful to define the controls on the guide geometry in SOPs. There is no correct way here, but rather whatever way best suites the desired workflow.","segments#Segments":"Segments are tags, and are defined using the same s[]@tags string array. The only difference in that segments are used to define segments of a rig; for example and arm, or spine.\nIn the example below we will use them to define the arm and leg segments and attach IK chains to them use the Autorig Component node.","skeleton-metadata-overview#Skeleton Metadata Overview":"","tags#Tags":"Tags are used to add metadata to a rig, allowing it to be setup procedurally. For example you could tag a characters arms, with the tags #arm and #left or #arm and #right. This would allow you to apply a rig component, for example an IK chain, to those joints without having to specify the joint names. This makes it easy to quickly and setup a rig on characters which may have different naming conventions or joint structures.\nTags are used heavily for both the Autorig Builder and Autorig Component nodes to specify how the component attaches to a rig.\nIn SOPs you can use the Attribute Adjust Tags node, which allows you to select joints and tag them in the viewport.\nAs tags are simply string arrays attribute, you can set them using VEX or VOPs. For example, to tag joints based on the side of a character:\ns[]@tags = {}; @P.x \u003e 0.01 ? append(s[]@tags, \"left\") : 0 ; @P.x \u003c -0.01 ? append(s[]@tags, \"right\") : 0 ; And as it is an attribute the usual tools for manipulating them are available to you in SOPs.\nTip\nTags are a concept that it worth getting familiar with; in this case we are defining tags on the guide geometry, however tags can also be use to tag nodes and ports in APEX graphs. This allows you to procedurally find nodes or ports when building graphs and is something we will heavily use later when building APEX graphs.","using-the-arm-segment-tag#Using the Arm Segment Tag":"Next we want to use the arm segment we setup to add an ik chain to our arms. This is pretty straightforward.\nGo to the fk Autorig Component node. From the Component Source parameter at the top of the node select Mulit IK. In the viewport you should see some controllers floating around. The component doesn’t know where to attach them and its guess is a bit off in this case. On the Driven tab there is a parm for segments. You could type r_arm l_arm, but the parameter allows for pattern matching, so we can just type *_arm to get the ik chains created for both arms.","using-the-fk-tag#Using the FK Tag":"The first thing we are going to do is to use the fk tags to promote the rotation for the finger joints (but not the arm joints as they’ll use an ik component). To do this we use a fk transform component on the Autorig Builder.\nAs we saw in the previous example, the fk transform creates joints for all of the joints on the skeleton. To get this working with our guide skeleton and tag, there are two parameters we need to change:\nUnder Source set the Skeleton to Guides.skel. This ensures it will use our tagged joints rather than the base skeleton. In the Controls tab, set the Promote R parameter to #fk. This means that it will only promote the joints with the fk tag. Looking in the viewport you should now only see controls for the finger joints."},"title":"Guides and Metadata"}}