{"/animated-pixels/docs/apex/01.getting_started/":{"data":{"":"This section gives a general introduction to APEX in Houdini. It assumes a basic understanding Houdini but no specific knowledge of rigging in Houdini.\nAn overview of rigging in Houdini Preparing geometry for APEX Using the Autorig Component to build a basic rig Skeleton Metadata: Preparing the Guide Skeleton Info\nThis set of tutorials were created for Houdini 21. APEX changed significantly between 20.5 and 21. It is strongly recommended to use Houdini 21 to ensure that everything works as expected.","contents#Contents":"00 Rigs in Houdini: The difference between KineFX and APEX 01 Workflow Overview: Overview of setting up an APEX Rig 02 Demo: A Simple Rig: Simple walkthrough of prepping geometry for a rig.","legend#Legend":"= Document = Example Scene ="},"title":"Getting Started"},"/animated-pixels/docs/apex/01.getting_started/00.rigs_in_houdini/":{"data":{"":"Rigging in Houdini consists of two overlapping systems:\nKineFX: KineFX uses geometry to define a skeleton and is used as the basis for the SOP based rigging tools, motion retargeting and crowd agent setup. APEX: APEX runs on its own execution engine, and is focuses on providing a procedural system for building rigs, tied to an animator friendly viewport state that efficient evaluates the rig. SideFX often use the two terms interchangeably and while there are some distinctions between the two, it makes sense. KineFX and SOPs prepare the skeleton and geometry, with APEX building the rig logic and animation controls.","apex-rigs#APEX Rigs":"While APEX is most often associated with rigging, it stands for All Purpose EXecution framework, and is also used for Houdini’s texturing and compositing framework Copernicus etc. It is an execution framework that runs outside of Houdini, with the emphasis on speed.\nFor rigging purposes, it provides a fast environment for executing the rig and deforming geometry, tied closely to the animation state. The main advantages of APEX are that it offers:\nViewport Oriented: Focusing on providing a fast, interactive viewport, with a range of useful tools for the animator. Flexible:Designed with traditional and ephemeral rigging in mind. Fast Evaluation: APEX graphs are both deferred and offer partial evaluation, using the GPU for geometry deformation. Procedural Graphs: APEX graphs can generate other APEX graph. This allows for procedural rig setup and also ephemeral rigging through procedurally attaching rigs during animation. Geometry: Apex graphs are represented as geometry with attributes. To a certain extent, this probably feels a slightly abstract, other than the UX and speed benefits, however they will hopefully become clearer as we step through the basics of creating a rig in APEX.","kinefx-rigs#KineFX Rigs":"KineFX rigs consist of points and polygon lines. The point contain the joint transform matrices and attributes (transform, local transform, scale, joint name), while the line defines the hierarchy of the skeleton.\nOne of the advantages of skeletons simply being points with a transform matrix is that Houdini’s usual geometry tools can be use to manipulate them, for example creating a skeleton based off a curve, or procedurally adding joints using a resample, or constraining joints to a surface using a primuv lookup.\nKineFX can be used for a wide range of tasks (and people are always using it in new and interesting ways!). It’s core uses would be for:\nMotion Editing: KineFX allows easy retargeting of motion from one rig onto another, cleaning up motion capture data and editing and manipulating motion. Simulation and Dynamics: Similarly to secondary motion, KineFX can be easily passed to solver, for example creating a skeleton for a tree, simulating it in vellum, and using that to deform the tree mesh. Rigs: KineFX fits within the Houdini toolset that most artist are familiar with. It can be used for rigging plants, generating muscle, building procedural rigs editing motion. Secondary Motion: Adding secondary motion on top of existing animation, for example lag, overshoot or jiggle. Given how flexible KineFX is, why would you use APEX? The main reasons that spring to mind are speed, interactivity."},"title":"00 Rigs in Houdini"},"/animated-pixels/docs/apex/01.getting_started/01.workflow_overview/":{"data":{"":"The basic rigging workflow for\nCreate a skeleton Capture the geometry Pack skin and skeleton for APEX Build rig in APEX","packed-folders#Packed Folders":"For the skin, skeleton and other data to be moved to the APEX environment it needs to be packed. Packed folders act as a containers. While anything can be put into a packed folder there are some conventions that get used by the default autorigs:\nBase.skel: The deformation skeleton. Guides.skel: The base skeleton, plus helper controls, joints and metadata for the rig. Base.shp: The skin geometry that gets deformed. And in terms of convention there are some default extensions:\nskel: Skeleton Geometry shp: Geometry (e.g. skin/blend shapes etc) rig: Rig logic (as we shall see apex rigs are stored as geometry). Everything used in the animate state is saved as a packed folder. For example:\nAnimation curves are primitives in an animation folder, Ragdoll geometry is just an additional shape folder with the collision geometry. - Constraints and locators are just rig logic in a packed folder that gets added to the rig graph. Control Library containing a shape library for the rig controls. You can add anything you could need to a packed folder to make it available to the rig; you are not restricted to the a specific set of packed folders.","skeleton#Skeleton":"The skeleton is defined by points with a transform attribute. At base, the points need to have:\ns@name: The name of the joint 3@transform: The transform matrix","skinning#Skinning":"The other main thing you need to have is a skinned mesh. There are three main ways to capture geometry in Houdini:\nJoint Capture Biharmonic: Uses biharmonic weighting to capture the geometry. Usually gives a good base weight with minimal tweaking. Proximity Capture: Captures based off proximity. Useful for things like cluster weights or simple weighting. Packed Capture: Captures packed geometry. This is useful for rigid objects or mechanical rigging. There are also the usual array of controls for painting or manipulating weights, however with a bit of forethought it is usually possible to create procedural skin weighting avoiding having to manually paint weights."},"title":"01 Workflow Overview I"},"/animated-pixels/docs/apex/01.getting_started/02.building_a_simple_rig/":{"data":{"":"The easiest way to see how this works is with a quick example. Rather than building everything from scratch, this will walk through this hip file: getting_startes.simple_rig.hiplc","apex-nodes#APEX Nodes":"Next up we have the APEX nodes. In this part of the network we are going to use the APEX Autorig Component node to build the rig from out skeleton. In our initial setup we are going to create use two autorig components:\nFK Transform: Adds controls for all the joints on the skeleton. Bone Deform: Deforms the skeleton using the joints. Tip\nEach autorig component has its own animate state so you can test the rig interactively as you build it.","apex-scene-animate#APEX Scene Animate":"The final node in our SOP chain is the APEX animate state. This is the node that the animator will use, and is focused on providing a fast interactive environment for animation alongside a suite of useful animation tools (from transient constraints to FBIK and physics).\nOur Capybara’s arm already had a bit of animation on it; if you scrub the timeline the arm and fingers should bend. Not the greatest animation perhaps, but there to prove a point; if you go back to the geometry network and switch the switch_delete_fingers to 1, you should see the fingers disappear, however the animation remains unchanged, similarly, setting it back to zero and the fingers should reappear with their animation.\nThis simple setup is fully procedural; as long as the controller names don’t change you can add additional features to the rig, but preserve the animation without having to throw away keyframes. Additionally you can swap in different packed folders, for example adding a different character, and still preserve the existing animation.\nYour browser doesn't support embedded videos, but don't worry, you can download it and watch it with your favorite video player!","create-the-rig-joints#Create The Rig Joints":"If you display the Create Joint Rig node and press enter in the viewport, you will see a control for each of the joints.\nAnd if you open an APEX Network View pane, it should look like this: The Autorig Component displays the nodes created by the current autorig component in green.\nThe FK Transform component is creating a Transform Object for each of the joints in the skeleton. These are the controllers that the animator interacts with. On the far right is the Input node; any Chanels plugged in here are promoted. For the joints we’ve promoted the rotation channel. The Point Transform takes the transform matrices from the Transform Objects and transforms the skeleton geometry by them.","deform-the-geometry#Deform The Geometry":"The second Autorig Component add the nodes necessary to deform the skin geometry.\nThis is the same at the SOP Joint Deform node. It takes the rest skeleton, the animated skeleton and uses the transforms to deform the skin geometry.","preparing-geometry-for-apex#Preparing Geometry For APEX":"The first step it to prepare the geometry for using it in APEX. This consists of three main steps:\nBuilding the Skeleton (optionally defining a guide skeleton) Capturing the skin Pack geometry into folders for apex. Skin: For this example we are going to be skinning the arm of the capybara. The first thing we want to do is delete everything apart from the arm. Skeleton: For the base skel, we use the skeleton node to create the skeleton. We can use the rig pane to quickly rename the joints as we create them. The Orient Joint node is used to orient the joints down the z axis. Guides: For the guides we are simply adding a tag to specify the arm segment. Tags are just a string array that exists on the Guides skeleton. Here we are just tagging the arm joints, which we are going to use later to apply a basic IK component procedurally. Tip\nThe pack folder SOP automatically names the folders it creates from the input node, and will automatically separate the name and extension for you."},"title":"02 Building A Simple Rig"}}